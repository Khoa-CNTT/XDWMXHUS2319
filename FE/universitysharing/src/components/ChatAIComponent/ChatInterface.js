import 'highlight.js/styles/atom-one-light.css';
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { Menu, Mic, Plus, Send, StopCircle } from 'react-feather';
import ReactMarkdown from 'react-markdown';
import { useDispatch, useSelector } from 'react-redux';
import rehypeHighlight from 'rehype-highlight';
import remarkGfm from 'remark-gfm';
import { useSignalR } from '../../Service/SignalRProvider';
import axiosClient from '../../Service/axiosClient';
import { useAuth } from '../../contexts/AuthContext';
import { confirmAction, fetchChatHistory, sendQuery, stopAction } from '../../stores/action/chatAIAction';
import './ChatInterface.scss';
import ConfirmationModal from './ConfirmationModal';
// Danh s√°ch tin nh·∫Øn th√†nh c√¥ng ng·∫´u nhi√™n cho t·ª´ng endpoint
const successMessages = {
  '/api/Post/create': [
    'Xong r·ªìi, m√¨nh ƒë√£ ƒëƒÉng b√†i vi·∫øt cho b·∫°n! üòÑ\n**Chi ti·∫øt b√†i ƒëƒÉng:**',
    'B√†i ƒëƒÉng c·ªßa b·∫°n ƒë√£ l√™n s√≥ng, tha h·ªì nh·∫≠n t∆∞∆°ng t√°c n√®! üéâ\n**Chi ti·∫øt b√†i ƒëƒÉng:**',
    'ƒê√£ ƒëƒÉng b√†i th√†nh c√¥ng, b·∫°n ƒë√∫ng l√† ng√¥i sao! üåü\n**Chi ti·∫øt b√†i ƒëƒÉng:**',
  ],
  '/api/Post/update-post': [
    'B√†i vi·∫øt ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t, nh√¨n x·ªãn h∆°n r·ªìi n√®! üòé\n**Chi ti·∫øt b√†i ƒëƒÉng:**',
    'Ok, b√†i ƒëƒÉng ƒë√£ ƒë∆∞·ª£c ch·ªânh s·ª≠a xong xu√¥i! üéâ\n**Chi ti·∫øt b√†i ƒëƒÉng:**',
    'C·∫≠p nh·∫≠t b√†i vi·∫øt th√†nh c√¥ng, b·∫°n pro gh√™! üòÑ\n**Chi ti·∫øt b√†i ƒëƒÉng:**',
  ],
  '/api/Post/delete': [
    'B√†i vi·∫øt ƒë√£ b·ªã x√≥a, g·ªçn g√†ng r·ªìi nha! üóëÔ∏è',
    'X√≥a b√†i vi·∫øt xong, nh·∫π c·∫£ ng∆∞·ªùi ha! üòå',
    'Ok, b√†i vi·∫øt ƒë√£ bi·∫øn m·∫•t kh√¥ng d·∫•u v·∫øt! üïµÔ∏è',
  ],
  '/api/Comment/CommentPost': [
    'B√¨nh lu·∫≠n c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c ƒëƒÉng, hot h√≤n h·ªçt! üî•\n**Chi ti·∫øt b√¨nh lu·∫≠n:**',
    'Xong, m√¨nh ƒë√£ th√™m b√¨nh lu·∫≠n cho b·∫°n n√®! üòé\n**Chi ti·∫øt b√¨nh lu·∫≠n:**',
    'B√¨nh lu·∫≠n ƒë√£ l√™n b√†i, m·ªçi ng∆∞·ªùi s·∫Øp ƒë·ªçc r·ªìi! üòÑ\n**Chi ti·∫øt b√¨nh lu·∫≠n:**',
  ],
  '/api/Comment/ReplyComment': [
    'Tr·∫£ l·ªùi b√¨nh lu·∫≠n ƒë√£ ƒë∆∞·ª£c g·ª≠i, b·∫°n ƒë√∫ng l√† nhanh tay! üòé\n**Chi ti·∫øt tr·∫£ l·ªùi:**',
    'Xong, m√¨nh ƒë√£ ƒëƒÉng c√¢u tr·∫£ l·ªùi cho b·∫°n! üéâ\n**Chi ti·∫øt tr·∫£ l·ªùi:**',
    'Ok, tr·∫£ l·ªùi b√¨nh lu·∫≠n ƒë√£ l√™n b√†i! üòÑ\n**Chi ti·∫øt tr·∫£ l·ªùi:**',
  ],
  '/api/Comment/UpdateComment': [
    'B√¨nh lu·∫≠n ƒë√£ ƒë∆∞·ª£c s·ª≠a, gi·ªù ·ªïn √°p r·ªìi nha! üòä\n**Chi ti·∫øt b√¨nh lu·∫≠n:**',
    'Xong, m√¨nh ƒë√£ c·∫≠p nh·∫≠t b√¨nh lu·∫≠n cho b·∫°n! üéä\n**Chi ti·∫øt b√¨nh lu·∫≠n:**',
    'Ok, b√¨nh lu·∫≠n ƒë√£ ƒë∆∞·ª£c ch·ªânh s·ª≠a, chu·∫©n lu√¥n! üëç\n**Chi ti·∫øt b√¨nh lu·∫≠n:**',
  ],
  '/api/Comment/DeleteComment': [
    'B√¨nh lu·∫≠n ƒë√£ b·ªã x√≥a, g·ªçn nh∆∞ ch∆∞a t·ª´ng c√≥! üò∂',
    'Xong, m√¨nh ƒë√£ d·ªçn d·∫πp b√¨nh lu·∫≠n cho b·∫°n r·ªìi! üßπ',
    'B√¨nh lu·∫≠n bi·∫øn m·∫•t r·ªìi, s·∫°ch s·∫Ω qu√° tr·ªùi! üö´',
  ],
  '/api/UserProfile/upProfile': [
    'H·ªì s∆° c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t, nh√¨n cool h∆°n r·ªìi! üòé\n**Chi ti·∫øt h·ªì s∆°:**',
    'Xong, th√¥ng tin c√° nh√¢n ƒë√£ ƒë∆∞·ª£c l√†m m·ªõi! üåü\n**Chi ti·∫øt h·ªì s∆°:**',
    'Ok, h·ªì s∆° ƒë√£ ƒë∆∞·ª£c ch·ªânh s·ª≠a, tuy·ªát v·ªùi! üéâ\n**Chi ti·∫øt h·ªì s∆°:**',
  ],
  '/api/UserProfile/upInformation': [
    'Th√¥ng tin c√° nh√¢n ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t, b·∫°n n·ªïi b·∫≠t h∆°n r·ªìi! üòÑ\n**Chi ti·∫øt th√¥ng tin:**',
    'Xong, th√¥ng tin c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c l√†m m·ªõi! üåü\n**Chi ti·∫øt th√¥ng tin:**',
    'Ok, th√¥ng tin ƒë√£ ƒë∆∞·ª£c ch·ªânh s·ª≠a, qu√° ch·∫•t! üéâ\n**Chi ti·∫øt th√¥ng tin:**',
  ],
  '/api/Like/like': [
    'Th·∫£ tim th√†nh c√¥ng, b√†i vi·∫øt th√™m hot! ‚ù§Ô∏è',
    'Xong, m√¨nh ƒë√£ like b√†i vi·∫øt cho b·∫°n n√®! üòÑ',
    'Like ƒë√£ ƒë∆∞·ª£c g·ª≠i, b·∫°n ƒë√∫ng l√† fan s·ªë 1! üî•',
  ],
  '/api/Like/unlike': [
    'ƒê√£ h·ªßy th·∫£ tim, ch·∫Øc b·∫°n ƒë·ªïi √Ω nh·ªâ? üò¢',
    'Ok, m√¨nh ƒë√£ g·ª° like kh·ªèi b√†i vi·∫øt! üëç',
    'Kh√¥ng c√≤n like n·ªØa, g·ªçn g√†ng ha! üíî',
  ],
  '/api/CommentLike/like': [
    'Like b√¨nh lu·∫≠n xong, b·∫°n ƒë√∫ng l√† fan s·ªë 1! üòç',
    'Xong, m√¨nh ƒë√£ th·∫£ tim cho b√¨nh lu·∫≠n n√®! üòä',
    'Ok, ƒë√£ like b√¨nh lu·∫≠n cho b·∫°n! üéâ',
  ],
  '/api/FriendShip/send-friend-request': [
    'L·ªùi m·ªùi k·∫øt b·∫°n ƒë√£ ƒë∆∞·ª£c g·ª≠i, ch·ªù h·ªìi √¢m nha! üòÑ',
    'Xong, m√¨nh ƒë√£ g·ª≠i y√™u c·∫ßu k·∫øt b·∫°n cho b·∫°n! üåü',
    'Y√™u c·∫ßu k·∫øt b·∫°n ƒë√£ bay ƒëi, s·∫Øp c√≥ b·∫°n m·ªõi! üöÄ',
  ],
  '/api/Share/SharePost': [
    'B√†i vi·∫øt ƒë√£ ƒë∆∞·ª£c chia s·∫ª, lan t·ªèa ngay th√¥i! üì¢',
    'Xong, m√¨nh ƒë√£ share b√†i vi·∫øt cho b·∫°n n√®! üòÑ',
    'Ok, b√†i vi·∫øt ƒë√£ ƒë∆∞·ª£c chia s·∫ª, hot l·∫Øm nha! üî•',
  ],
  '/api/Ride/create': [
    'Chuy·∫øn ƒëi ƒë√£ ƒë∆∞·ª£c t·∫°o, s·∫µn s√†ng l√™n xe th√¥i! üöó\n**Chi ti·∫øt chuy·∫øn ƒëi:**',
    'Xong, m√¨nh ƒë√£ t·∫°o chuy·∫øn ƒëi cho b·∫°n n√®! üòÑ\n**Chi ti·∫øt chuy·∫øn ƒëi:**',
    'Ok, chuy·∫øn ƒëi ƒë√£ ƒë∆∞·ª£c x√°c nh·∫≠n, qu√° tuy·ªát! üéâ\n**Chi ti·∫øt chuy·∫øn ƒëi:**',
  ],
  'default': [
    'H√†nh ƒë·ªông ƒë√£ ho√†n t·∫•t, b·∫°n ƒë·ªânh th·∫≠t! üòÑ',
    'Xong xu√¥i h·∫øt r·ªìi, m√¨nh l√†m t·ªët ch·ª©? üòé',
    'Ok, m·ªçi th·ª© ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω ngon l√†nh! üéâ',
  ],
};
const paramDisplayMap = {
  '/api/Post/create': {
    Content: 'N·ªôi dung b√†i ƒëƒÉng',
    Images: 'H√¨nh ·∫£nh k√®m theo',
    Video: 'Video k√®m theo',
    Scope: 'Ph·∫°m vi b√†i ƒëƒÉng',
  },
  '/api/Post/update-post': {
    PostId: 'ID b√†i ƒëƒÉng',
    Content: 'N·ªôi dung b√†i ƒëƒÉng',
    Images: 'H√¨nh ·∫£nh k√®m theo',
    Video: 'Video k√®m theo',
    Scope: 'Ph·∫°m vi b√†i ƒëƒÉng',
  },
  '/api/Ride/create': {
    DriverId: 'ID T√†i x·∫ø',
    RidePostId: 'ID b√†i ƒëƒÉng',
    IsSafetyTrackingEnabled: 'Ch·∫ø ƒë·ªô an to√†n',
  },
  '/api/Comment/CommentPost': {
    PostId: 'ID b√†i ƒëƒÉng',
    Content: 'N·ªôi dung b√¨nh lu·∫≠n',
  },
  '/api/Comment/ReplyComment': {
    PostId: 'ID b√†i ƒëƒÉng',
    ParentCommentId: 'ID b√¨nh lu·∫≠n cha',
    Content: 'N·ªôi dung tr·∫£ l·ªùi',
  },
  '/api/Like/like': {
    PostId: 'ID b√†i ƒëƒÉng',
  },
  '/api/CommentLike/like': {
    CommentId: 'ID b√¨nh lu·∫≠n',
  },
  '/api/FriendShip/send-friend-request': {
    FriendId: 'ID b·∫°n b√®',
  },
  '/api/Share/SharePost': {
    PostId: 'ID b√†i ƒëƒÉng',
    Content: 'N·ªôi dung chia s·∫ª',
  },
  '/api/UserProfile/upProfile': {
    FullName: 'H·ªç v√† t√™n',
    ProfileImage: '·∫¢nh ƒë·∫°i di·ªán',
    BackgroundImage: '·∫¢nh b√¨a',
    Bio: 'Ti·ªÉu s·ª≠',
    PhoneNumber: 'S·ªë ƒëi·ªán tho·∫°i',
    PhoneRelativeNumber: 'S·ªë ƒëi·ªán tho·∫°i ng∆∞·ªùi th√¢n',
  },
  '/api/UserProfile/upInformation': {
    PhoneNumber: 'S·ªë ƒëi·ªán tho·∫°i',
    PhoneRelativeNumber: 'S·ªë ƒëi·ªán tho·∫°i ng∆∞·ªùi th√¢n',
    Gender: 'Gi·ªõi t√≠nh',
  },
};
const scopeOptions = [
  { value: 0, label: 'C√¥ng khai' },
  { value: 1, label: 'B·∫°n b√®' },
  { value: 2, label: 'Ri√™ng t∆∞' },
];

const genderOptions = [
  { value: 'Male', label: 'Nam' },
  { value: 'Female', label: 'N·ªØ' },
  { value: 'Other', label: 'Kh√°c' },
];

const isSafeOptions = [
  { value: true, label: 'ƒê·ªìng √Ω' },
  { value: false, label: 'Kh√¥ng ƒë·ªìng √Ω' },
];
// H√†m ti·ªÅn x·ª≠ l√Ω markdown
const preprocessMarkdown = (text) => {
  return text.replace(/^\*(\S)/gm, '* $1').replace(/^\*\*(\S)/gm, '** $1');
};

// S·ª≠a h√†m convertLinksToMarkdown
const convertLinksToMarkdown = (content) => {
  // B·∫£o v·ªá c√∫ ph√°p h√¨nh ·∫£nh markdown tr∆∞·ªõc khi x·ª≠ l√Ω li√™n k·∫øt
  const imagePlaceholder = '___IMAGE___';
  const images = [];
  let tempContent = content;

  // T√¨m v√† thay th·∫ø c√°c c√∫ ph√°p h√¨nh ·∫£nh b·∫±ng placeholder
  tempContent = tempContent.replace(
    /!\[([^\]]*)\]\((https?:\/\/[^\s)]+)\)/g,
    (match) => {
      images.push(match);
      return imagePlaceholder;
    }
  );

  // Chuy·ªÉn c√°c URL th√†nh c√∫ ph√°p li√™n k·∫øt markdown, nh∆∞ng kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn placeholder
  const urlRegex = /(?:https?:\/\/[^\s]+)/g;
  tempContent = tempContent.replace(urlRegex, (url) => {
    if (tempContent.includes(imagePlaceholder)) {
      return url; // B·ªè qua n·∫øu URL n·∫±m trong placeholder
    }
    return `[${url}](${url})`;
  });

  // Kh√¥i ph·ª•c c√°c c√∫ ph√°p h√¨nh ·∫£nh
  images.forEach((image, index) => {
    tempContent = tempContent.replace(imagePlaceholder, image);
  });

  return tempContent;
};

const ChatInterface = ({ conversationId, setConversationId, toggleSidebar, onNewChat }) => {
  const dispatch = useDispatch();
  const { userId } = useAuth();
  const { signalRService, isConnected } = useSignalR();
  const { currentConversation, isLoading, error, chatHistory, currentConversationId } = useSelector((state) => state.chatAI);
  const [query, setQuery] = useState('');
  const [messages, setMessages] = useState([]);
  const [isWaitingResponse, setIsWaitingResponse] = useState(false);
  const [currentStreamId, setCurrentStreamId] = useState(null);
  const messagesEndRef = useRef(null);
  const inputRef = useRef(null);
  const chunkBufferRef = useRef('');
  const pendingChunksRef = useRef({});
  const processedChunks = useRef(new Set());
  const pendingMessageRef = useRef(null); // L∆∞u tin nh·∫Øn AI t·∫°m th·ªùi
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isListening, setIsListening] = useState(false);
  const speechRecognitionRef = useRef(null);
  const silenceTimerRef = useRef(null);
  const queryAtMicStartRef = useRef('');
  const startSilenceTimer = useCallback(() => {
    clearTimeout(silenceTimerRef.current);
    silenceTimerRef.current = setTimeout(() => {
      if (speechRecognitionRef.current && isListening) { // Ki·ªÉm tra isListening ƒë·ªÉ tr√°nh g·ªçi stop kh√¥ng c·∫ßn thi·∫øt
        console.log('[SpeechRecognition] Silence timeout (3s). Stopping recognition.');
        speechRecognitionRef.current.stop(); // S·∫Ω trigger onend, v√† onend s·∫Ω set isListening = false
      }
    }, 3000); // 3 gi√¢y
  }, [isListening]);
  useEffect(() => {
    console.log('[SpeechRecognition] useEffect setup running...');
    const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
  
    let recognitionInstance = null; // ‚úÖ ƒê∆∞a ra ngo√†i ƒë·ªÉ d√πng ƒë∆∞·ª£c trong cleanup
  
    if (SpeechRecognitionAPI) {
      console.log('[SpeechRecognition] Web Speech API is available.');
      recognitionInstance = new SpeechRecognitionAPI();
      speechRecognitionRef.current = recognitionInstance;
  
      recognitionInstance.continuous = true;
      recognitionInstance.lang = 'vi-VN';
      recognitionInstance.interimResults = true;
  
      recognitionInstance.onstart = () => {
        console.log('[SpeechRecognition] onstart: Recognition service has started.');
        startSilenceTimer();
      };
  
      recognitionInstance.onresult = (event) => {
        console.log('[SpeechRecognition] onresult event triggered.');
        startSilenceTimer();
  
        let interim_transcript = '';
        let final_transcript = queryAtMicStartRef.current;
  
        for (let i = event.resultIndex; i < event.results.length; ++i) {
          const transcript_segment = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            final_transcript += transcript_segment;
            queryAtMicStartRef.current = final_transcript;
          } else {
            interim_transcript += transcript_segment;
          }
        }
  
        setQuery(final_transcript + interim_transcript);
        console.log(`[SpeechRecognition] Interim/Final. Query set to: "${final_transcript + interim_transcript}"`);
      };
  
      recognitionInstance.onerror = (event) => {
        console.error('[SpeechRecognition] onerror event:', event.error);
        clearTimeout(silenceTimerRef.current);
        let errorMessage = `L·ªói nh·∫≠n d·∫°ng gi·ªçng n√≥i: ${event.error}`;
        if (event.error === 'no-speech') {
           errorMessage = 'Kh√¥ng nh·∫≠n di·ªán ƒë∆∞·ª£c gi·ªçng n√≥i ban ƒë·∫ßu.';
        } else if (event.error === 'audio-capture') {
           errorMessage = 'L·ªói micro. Vui l√≤ng ki·ªÉm tra micro c·ªßa b·∫°n.';
        } else if (event.error === 'not-allowed') {
           errorMessage = 'B·∫°n ƒë√£ kh√¥ng c·∫•p quy·ªÅn s·ª≠ d·ª•ng micro.';
        }
        if (event.error !== 'no-speech') {
           alert(errorMessage);
        }
      };
  
      recognitionInstance.onend = () => {
        console.log('[SpeechRecognition] onend: Recognition service disconnected.');
        clearTimeout(silenceTimerRef.current);
        setIsListening(false);
        queryAtMicStartRef.current = "";
      };
    } else {
      console.warn('[SpeechRecognition] Tr√¨nh duy·ªát n√†y kh√¥ng h·ªó tr·ª£ Web Speech API.');
      alert('Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ t√≠nh nƒÉng nh·∫≠n d·∫°ng gi·ªçng n√≥i.');
    }
  
    return () => {
      console.log('[SpeechRecognition] useEffect cleanup: Stopping recognition.');
      clearTimeout(silenceTimerRef.current);
      if (recognitionInstance) {
        recognitionInstance.onstart = null;
        recognitionInstance.onresult = null;
        recognitionInstance.onerror = null;
        recognitionInstance.onend = null;
        recognitionInstance.stop();
      }
    };
  }, []);
  

  const handleToggleListening = () => {
    if (!speechRecognitionRef.current) {
      alert('T√≠nh nƒÉng nh·∫≠n d·∫°ng gi·ªçng n√≥i ch∆∞a s·∫µn s√†ng.');
      return;
    }
  
    if (isListening) {
      console.log('[SpeechControls] User stopping listening.');
      clearTimeout(silenceTimerRef.current);
      try {
        speechRecognitionRef.current.stop(); // s·∫Ω g·ªçi onend
      } catch (e) {
        console.error('[SpeechControls] Error stopping mic:', e);
      }
    } else {
      console.log('[SpeechControls] User starting listening.');
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(() => {
          console.log('[SpeechControls] Microphone permission granted.');
          queryAtMicStartRef.current = query;
          try {
            speechRecognitionRef.current.start();
            setIsListening(true); // ‚úÖ Cho n√∫t chuy·ªÉn ngay
          } catch (e) {
            console.error('[SpeechControls] Error calling .start():', e);
            setIsListening(false);
            alert('Kh√¥ng th·ªÉ b·∫≠t mic. C√≥ th·ªÉ tr√¨nh duy·ªát ƒëang ghi √¢m ho·∫∑c ch∆∞a h·ªó tr·ª£.');
          }
        })
        .catch(err => {
          console.error('[SpeechControls] Cannot access microphone:', err);
          alert('Kh√¥ng th·ªÉ truy c·∫≠p micro. Vui l√≤ng ki·ªÉm tra quy·ªÅn truy c·∫≠p.');
          setIsListening(false);
        });
    }
  };
  
  useEffect(() => {
    const hasModal = messages.some((msg) => msg.isConfirmationModal);
    setIsModalOpen(hasModal);
  }, [messages]);
  // ƒê·ªìng b·ªô messages v·ªõi chatHistory t·ª´ Redux
  useEffect(() => {
    console.log('[useEffect] Triggered. conversationId:', conversationId, 'currentConversationId:', currentConversationId, 'chatHistory:', chatHistory, 'isWaitingResponse:', isWaitingResponse);
  
    if (conversationId && chatHistory && chatHistory.length > 0 && !isWaitingResponse) {
      console.log('[useEffect] Syncing chatHistory with messages for conversationId:', conversationId);
  
      setMessages((prevMessages) => {
        console.log('[useEffect] Previous messages:', prevMessages);
  
        // L·ªçc tin nh·∫Øn thu·ªôc conversationId hi·ªán t·∫°i ho·∫∑c tin nh·∫Øn t·∫°m th·ªùi
        const updatedMessages = prevMessages.filter((msg) => {
          const isCurrentConversation = msg.conversationId === conversationId;
          // Gi·ªØ tin nh·∫Øn t·∫°m th·ªùi ngay c·∫£ khi currentStreamId l√† null
          const isTempMessage = msg.tempConversationId && (msg.tempConversationId === currentStreamId || currentStreamId === null);
          const shouldKeep = isCurrentConversation || isTempMessage || msg.id.startsWith('confirmation-');
          console.log('[useEffect] Keeping message:', msg, 'Keep:', shouldKeep);
          return shouldKeep;
        });
  
        const existingMessageIds = new Set(updatedMessages.map((msg) => msg.id));
  
        const filteredHistory = chatHistory
          .filter((history) => {
            const shouldInclude = (
              //history.answer !== 'H√†nh ƒë·ªông ƒëang th·ª±c thi' &&
              !history.isConfirmationModal &&
              !existingMessageIds.has(`user-${history.id}`) &&
              !existingMessageIds.has(`ai-${history.id}`) &&
              !existingMessageIds.has(`ai-confirm-${history.id}`)
            );
            console.log('[useEffect] Filtering history item:', history, 'Include:', shouldInclude);
            return shouldInclude;
          })
          .map((history) => [
            {
              id: `user-${history.id}`,
              content: history.query,
              isUser: true,
              isStreaming: false,
              showDots: false,
              timestamp: history.timestamp,
              conversationId, // G·∫Øn conversationId
            },
            {
              id: `ai-${history.id}`,
              content: history.answer,
              isUser: false,
              isStreaming: false,
              showDots: false,
              timestamp: history.timestamp,
              conversationId, // G·∫Øn conversationId
            },
          ])
          .flat();
  
        console.log('[useEffect] Filtered history:', filteredHistory);
  
        // K·∫øt h·ª£p v√† s·∫Øp x·∫øp theo timestamp
        return [...updatedMessages, ...filteredHistory].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
      });
    } else if (!conversationId && !isWaitingResponse) {
      console.log('[useEffect] Resetting messages for new conversation');
      setMessages([]);
    } else {
      console.log('[useEffect] Keeping current messages, no sync needed');
    }
  }, [conversationId, chatHistory, currentConversationId, isWaitingResponse, currentStreamId]);

  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  // Reset messages only when starting a new conversation
  useEffect(() => {
    if (!conversationId && !isWaitingResponse && !currentStreamId) {
      console.log('[ChatInterface] Resetting state for new conversation');
      inputRef.current?.focus();
      setMessages([]);
      setCurrentStreamId(null);
      chunkBufferRef.current = '';
      pendingChunksRef.current = {};
      pendingMessageRef.current = null;
    }
  }, [conversationId, isWaitingResponse, currentStreamId]);

  // Setup SignalR listeners
  useEffect(() => {
    if (!isConnected || !signalRService) {
      console.log('[ChatInterface] SignalR not connected, skipping listener setup');
      return;
    }

    console.log('[ChatInterface] Setting up SignalR listeners');
    const handleChunk = (chunk, streamId) => {
      console.log('[handleChunk] Received chunk:', chunk, 'StreamId:', streamId);
    
      const chunkKey = `${streamId}-${chunk}`;
      if (processedChunks.current.has(chunkKey)) {
        console.log(`[handleChunk] Skipping duplicate chunk for streamId: ${streamId}`);
        return;
      }
      processedChunks.current.add(chunkKey);
    
      const aiMessageId = `ai-${streamId}`;
      const hasMatchingMessage = messages.some((msg) => msg.id === aiMessageId) || pendingMessageRef.current?.id === aiMessageId;
    
      if (!hasMatchingMessage) {
        console.log(`[handleChunk] No matching AI message for streamId: ${streamId}, storing chunk`);
        pendingChunksRef.current[streamId] = (pendingChunksRef.current[streamId] || '') + chunk;
        return;
      }
    
      if (chunk && typeof chunk === 'string') {
        chunkBufferRef.current += chunk;
        console.log('[handleChunk] Current chunk buffer:', chunkBufferRef.current);
      } else {
        console.warn('[handleChunk] Received empty or invalid chunk:', chunk);
        return;
      }
    
      setMessages((prev) => {
        const updatedMessages = prev.map((msg) => {
          if (msg.id === aiMessageId) {
            return {
              ...msg,
              content: chunkBufferRef.current,
              showDots: true,
              timestamp: new Date().toISOString(),
            };
          }
          return msg;
        });
    
        if (!prev.some((msg) => msg.id === aiMessageId) && pendingMessageRef.current?.id === aiMessageId) {
          return [
            ...updatedMessages,
            {
              ...pendingMessageRef.current,
              content: chunkBufferRef.current,
              showDots: true,
              timestamp: new Date().toISOString(),
            },
          ];
        }
        console.log('[handleChunk] Updated messages:', updatedMessages);
        return updatedMessages;
      });
    };
    const handleComplete = (content, streamId) => {
      console.log('[ChatInterface] Received complete data:', JSON.stringify(content, null, 2), 'StreamId:', streamId);
      if (content && content.results && Array.isArray(content.results) && content.results.length > 0) {
              console.log('chunkBufferRef.current.trim()',chunkBufferRef.current.trim());
        const finalContent = chunkBufferRef.current.trim() || 'T√¥i c·∫ßn b·∫°n xem x√©t l·∫°i c√°c th√¥ng tin.';
        setMessages((prev) => {
          const aiMessageId = `ai-${streamId}`;
          const updatedMessages = prev.map((msg) => {
            if (msg.id === aiMessageId) {
              return {
                ...msg,
                content: finalContent,
                isStreaming: false,
                showDots: false,
                timestamp: new Date().toISOString(),
                conversationId: conversationId || msg.conversationId, // G·∫Øn conversationId
              };
            }
            return msg;
          });
          // Ch·ªâ th√™m modal n·∫øu ch∆∞a t·ªìn t·∫°i
          if (!updatedMessages.some((msg) => msg.id === `confirmation-${streamId}`)) {
            return [
              ...updatedMessages,
              {
                id: `confirmation-${streamId}`,
                isUser: false,
                isStreaming: false,
                showDots: false,
                isConfirmationModal: true,
                results: content.results,
                streamId,
                chatHistoryId: content.chatHistoryId,
                timestamp: new Date().toISOString(),
                conversationId, // G·∫Øn conversationId
              },
            ].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
          }
          return updatedMessages;
        });
    
        // Reset tr·∫°ng th√°i
        setIsWaitingResponse(false);
        if (conversationId && !chatHistory.some((history) => history.id === streamId)) {
          dispatch(fetchChatHistory({ conversationId, lastMessageId: null }));
        }
        setCurrentStreamId(null);
        chunkBufferRef.current = '';
        processedChunks.current.clear();
        pendingMessageRef.current = null;
      } else {
        console.warn('[ChatInterface] Invalid or empty complete data:', JSON.stringify(content, null, 2));
        setMessages((prev) => {
          const updatedMessages = prev.filter((msg) => msg.id !== `ai-${streamId}`);
          return [
            ...updatedMessages,
            {
              id: `error-${Date.now()}`,
              content: 'D·ªØ li·ªáu x√°c nh·∫≠n kh√¥ng h·ª£p l·ªá. Vui l√≤ng th·ª≠ l·∫°i.',
              isUser: false,
              isStreaming: false,
              showDots: false,
              isError: true,
              timestamp: new Date().toISOString(),
              conversationId, // G·∫Øn conversationId
            },
          ].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        });
        setIsWaitingResponse(false);
        setCurrentStreamId(null);
        chunkBufferRef.current = '';
        processedChunks.current.clear();
        pendingMessageRef.current = null;
      }
    };
    const handleStreamCompleted = (streamId) => {
      console.log('[handleStreamCompleted] Stream completed:', streamId);
    
      if (pendingChunksRef.current[streamId]) {
        chunkBufferRef.current = pendingChunksRef.current[streamId];
        delete pendingChunksRef.current[streamId];
      }
    
      const finalContent = chunkBufferRef.current.trim() || 'Kh√¥ng nh·∫≠n ƒë∆∞·ª£c ph·∫£n h·ªìi t·ª´ AI.';
      setMessages((prev) => {
        const aiMessageId = `ai-${streamId}`;
        const updatedMessages = prev.map((msg) => {
          if (msg.id === aiMessageId) {
            return {
              ...msg,
              content: finalContent,
              isStreaming: false,
              showDots: false,
              timestamp: new Date().toISOString(),
              conversationId: conversationId || msg.conversationId, // G·∫Øn conversationId
            };
          }
          return msg;
        });
    
        if (!prev.some((msg) => msg.id === aiMessageId) && pendingMessageRef.current?.id === aiMessageId) {
          return [
            ...updatedMessages,
            {
              ...pendingMessageRef.current,
              content: finalContent,
              isStreaming: false,
              showDots: false,
              timestamp: new Date().toISOString(),
              conversationId, // G·∫Øn conversationId
            },
          ].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        }
        console.log('[handleStreamCompleted] Updated messages:', updatedMessages);
        return updatedMessages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
      });
    
      setIsWaitingResponse(false);
      if (conversationId) {
        dispatch(fetchChatHistory({ conversationId, lastMessageId: null }));
      }
      // Tr√¨ ho√£n ƒë·∫∑t currentStreamId ƒë·ªÉ useEffect x·ª≠ l√Ω tin nh·∫Øn t·∫°m th·ªùi
      setTimeout(() => {
        setCurrentStreamId(null);
        chunkBufferRef.current = '';
        processedChunks.current.clear();
        pendingMessageRef.current = null;
      }, 0);
    };

    signalRService.onReceiveChunk(handleChunk);
    signalRService.onReceiveComplete(handleComplete);
    signalRService.onStreamCompleted(handleStreamCompleted);

    return () => {
      console.log('[ChatInterface] Cleaning up SignalR listeners');
      signalRService.off('ReceiveChunk', handleChunk);
      signalRService.off('ReceiveComplete', handleComplete);
      signalRService.off('StreamCompleted', handleStreamCompleted);
    };

  }, [isConnected, signalRService, dispatch]);

  const handleSendQuery = useCallback(() => {
    if (!query.trim() || isWaitingResponse) return;
  
    const userQuery = query.trim();
    const newStreamId = Date.now().toString();
    const userMessageId = `user-${newStreamId}`;
    const aiMessageId = `ai-${newStreamId}`;
    const now = new Date().toISOString();
  
    console.log('[handleSendQuery] Sending query:', userQuery, 'StreamId:', newStreamId);
  
    if (!conversationId) {
      setMessages([]);
      chunkBufferRef.current = '';
      pendingChunksRef.current = {};
      pendingMessageRef.current = null;
    }
  
    pendingMessageRef.current = {
      id: aiMessageId,
      content: '',
      isUser: false,
      isStreaming: true,
      showDots: true,
      timestamp: now,
      tempConversationId: newStreamId, // G·∫Øn tempConversationId
    };
  
    const newMessages = [
      ...messages,
      {
        id: userMessageId,
        content: userQuery,
        isUser: true,
        isStreaming: false,
        showDots: false,
        timestamp: now,
        tempConversationId: newStreamId, // G·∫Øn tempConversationId
      },
      pendingMessageRef.current,
    ];
    setMessages([...newMessages]);
    console.log('[handleSendQuery] Updated messages:', newMessages);
  
    setIsWaitingResponse(true);
    setQuery('');
    setCurrentStreamId(newStreamId);
    chunkBufferRef.current = '';
    processedChunks.current.clear();
  
    dispatch(sendQuery({ query: userQuery, conversationId: conversationId || null }))
      .then((action) => {
        const newConversationId = action.payload?.conversationId;
        const queryToSend = action.payload?.query;
        console.log('[handleSendQuery] sendQuery response:', action.payload);
  
        const streamConversationId = conversationId || newConversationId;
        if (streamConversationId && queryToSend && signalRService && isConnected) {
          console.log('[handleSendQuery] Starting stream with query:', queryToSend, 'streamId:', newStreamId);
          signalRService.sendStreamQuery(queryToSend, streamConversationId, newStreamId);
        } else {
          throw new Error('Cannot start stream: Missing required parameters');
        }
  
        if (!conversationId && newConversationId) {
          console.log('[handleSendQuery] New conversation created with ID:', newConversationId);
          setConversationId(newConversationId);
          // C·∫≠p nh·∫≠t tempConversationId th√†nh conversationId
          setMessages((prev) =>
            prev.map((msg) =>
              msg.tempConversationId === newStreamId
                ? { ...msg, conversationId: newConversationId, tempConversationId: undefined }
                : msg
            )
          );
          dispatch(fetchChatHistory({ conversationId: newConversationId, lastMessageId: null }));
        }
      })
      .catch((err) => {
        console.error('[handleSendQuery] Error sending message:', err);
        setIsWaitingResponse(false);
        setCurrentStreamId(null);
        setMessages((prev) => [
          ...prev.filter((msg) => msg.id !== aiMessageId),
          {
            id: `error-${Date.now()}`,
            content: 'ƒê√£ x·∫£y ra l·ªói khi g·ª≠i tin nh·∫Øn. Vui l√≤ng th·ª≠ l·∫°i.',
            isUser: false,
            isStreaming: false,
            showDots: false,
            isError: true,
            timestamp: new Date().toISOString(),
          },
        ]);
        chunkBufferRef.current = '';
        processedChunks.current.clear();
        pendingMessageRef.current = null;
      });
  }, [query, isWaitingResponse, dispatch, conversationId, signalRService, setConversationId, isConnected, messages]);

  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendQuery();
    }
  };

  const handleNewChat = useCallback(() => {
    console.log('[ChatInterface] Starting new chat');
    setMessages([]);
    setCurrentStreamId(null);
    chunkBufferRef.current = '';
    pendingChunksRef.current = {};
    pendingMessageRef.current = null;
    setConversationId(null);
    setIsWaitingResponse(false); // ƒê·∫∑t l·∫°i tr·∫°ng th√°i ch·ªù
    onNewChat();
  }, [onNewChat, setConversationId]);
 
const handleModalConfirm = useCallback(
  async (endpoint, params, redis_key, streamId) => {
    console.log('[ChatInterface] Confirming action:', { endpoint, params, redis_key, streamId, conversationId });
    if (!endpoint || !params || !redis_key || !streamId) {
      console.error('[ChatInterface] Invalid confirm action parameters:', { endpoint, params, redis_key, streamId });
      setMessages((prev) => {
        const updatedMessages = prev.filter((msg) => !msg.isConfirmationModal);
        return [
          ...updatedMessages,
          {
            id: `error-${Date.now()}`,
            content: 'Th√¥ng tin x√°c nh·∫≠n kh√¥ng h·ª£p l·ªá. Vui l√≤ng th·ª≠ l·∫°i.',
            isUser: false,
            isStreaming: false,
            showDots: false,
            isError: true,
            timestamp: new Date().toISOString(),
            conversationId,
          },
        ].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
      });
      setIsModalOpen(false);
      setIsWaitingResponse(false);
      return;
    }

    // Danh s√°ch th√¥ng b√°o l·ªói th√¢n thi·ªán ng·∫´u nhi√™n
    const friendlyErrorMessages = [
      '√îi, c√≥ v·∫ª nh∆∞ h·ªá th·ªëng h∆°i m√® nheo r·ªìi! üòÖ',
      'Hic, c√≥ ch√∫t tr·ª•c tr·∫∑c nh·ªè, th·ª≠ l·∫°i nh√©! üõ†Ô∏è',
      '√öi, h·ªá th·ªëng ƒëang b·∫≠n t√≠ x√≠u, ch·ªù ch√∫t nha! ‚è≥',
      '√îi z·ªùi, c√≥ g√¨ ƒë√≥ kh√¥ng ·ªïn r·ªìi, ƒë·ªÉ m√¨nh ki·ªÉm tra l·∫°i! üòì',
      'H·ªá th·ªëng h∆°i ngh·ªãch ng·ª£m t√≠, th·ª≠ l·∫°i n√†o! üòú',
    ];

    try {
      const confirmationMessage = messages.find((msg) => msg.id === `confirmation-${streamId}`);
      const chatHistoryId = confirmationMessage?.chatHistoryId || null; // Cung c·∫•p gi√° tr·ªã m·∫∑c ƒë·ªãnh

      // N·∫øu chatHistoryId kh√¥ng t·ªìn t·∫°i, ghi log c·∫£nh b√°o
      if (!chatHistoryId) {
        console.warn('[ChatInterface] chatHistoryId is undefined for streamId:', streamId);
      }

      const endpointKey = endpoint.replace('https://localhost:7053', '');
      const messagesForEndpoint = successMessages[endpointKey] || successMessages['default'];
      const successMessage = messagesForEndpoint[Math.floor(Math.random() * messagesForEndpoint.length)];

      // Chu·∫©n h√≥a params th√†nh m·ªôt m·∫£ng ch·ª©a m·ªôt ƒë·ªëi t∆∞·ª£ng duy nh·∫•t
      // const normalizedParams = [{
      //   ...params[0], // params ƒë√£ ƒë∆∞·ª£c chu·∫©n h√≥a trong ConfirmationModal.js
      // }];
      console.log("paramsHandlerConf",params);
      // G·ªçi confirmAction m√† kh√¥ng g·ª≠i successMessage
      const result = await dispatch(
        confirmAction({ endpoint, params, redis_key, conversationId, chatHistoryId })
      ).unwrap();
      console.log('[ChatInterface] Action confirmed result:', result);

      // Ki·ªÉm tra m√£ tr·∫°ng th√°i t·ª´ server
      if (result.response && result.response.code === 200) {
  // Th√†nh c√¥ng: T·∫°o n·ªôi dung tin nh·∫Øn bao g·ªìm successMessage v√† d·ªØ li·ªáu tr·∫£ v·ªÅ
  const endpointKey = endpoint.replace('https://localhost:7053', '');
  const messagesForEndpoint = successMessages[endpointKey] || successMessages['default'];
  const successMessage = messagesForEndpoint[Math.floor(Math.random() * messagesForEndpoint.length)];

  // Format d·ªØ li·ªáu tr·∫£ v·ªÅ t·ª´ server th√†nh chu·ªói d·ªÖ ƒë·ªçc
  let dataMessage = '';
  if (result.response.data && paramDisplayMap[endpointKey]) {
    const data = result.response.data;
    const displayMap = paramDisplayMap[endpointKey];

    // L·ªçc c√°c tr∆∞·ªùng kh√¥ng ph·∫£i ID v√† t·∫°o danh s√°ch chi ti·∫øt
    dataMessage = Object.entries(displayMap)
      .map(([paramKey, displayName]) => {
        // B·ªè qua c√°c tr∆∞·ªùng li√™n quan ƒë·∫øn ID
        if (paramKey.toLowerCase().includes('id')) return null;

        // L·∫•y gi√° tr·ªã t·ª´ data, ∆∞u ti√™n key t·ª´ data n·∫øu c√≥
        let value = data[paramKey] || data[paramKey.toLowerCase()] || data[paramKey.toUpperCase()];
        if (value === null || value === undefined) {
          // Ki·ªÉm tra c√°c tr∆∞·ªùng kh√°c trong data n·∫øu kh√¥ng t√¨m th·∫•y paramKey
          const fallbackKey = Object.keys(data).find(
            (key) => key.toLowerCase() === paramKey.toLowerCase()
          );
          value = fallbackKey ? data[fallbackKey] : null;
        }
        if (value === null || value === undefined) return null;

        // ƒê·ªãnh d·∫°ng gi√° tr·ªã ph√π h·ª£p
        if (paramKey === 'Scope') {
          const scopeOption = scopeOptions.find(
            (opt) => opt.value === value || opt.value.toString() === value.toString()
          );
          value = scopeOption ? scopeOption.label : value;
        } else if (paramKey === 'IsSafetyTrackingEnabled') {
          const safeOption = isSafeOptions.find((opt) => opt.value === value);
          value = safeOption ? safeOption.label : value;
        } else if (paramKey === 'Gender') {
          const genderOption = genderOptions.find((opt) => opt.value === value);
          value = genderOption ? genderOption.label : value;
        } else if (typeof value === 'boolean') {
          value = value ? 'Th√†nh c√¥ng' : 'ƒê√£ h·ªßy';
        } else if (paramKey === 'Images' || paramKey === 'ProfileImage' || paramKey === 'BackgroundImage') {
          // X·ª≠ l√Ω h√¨nh ·∫£nh
          if (Array.isArray(value)) {
            return value
              .map((img, index) => {
                const fullUrl = img.startsWith('http') ? img : `https://localhost:7053${img}`;
                return `- ${displayName} ${index + 1}: ![${displayName} ${index + 1}](${fullUrl})`;
              })
              .join('\n');
          } else if (typeof value === 'string') {
            const fullUrl = value.startsWith('http') ? value : `https://localhost:7053${value}`;
            return `- ${displayName}: ![${displayName}](${fullUrl})`;
          }
          return null;
        }

        // X·ª≠ l√Ω tr∆∞·ªùng imageUrl (cho c√°c endpoint nh∆∞ /api/Post/update-post)
        if (paramKey.toLowerCase() === 'imageurl' && typeof value === 'string') {
          const fullUrl = value.startsWith('http') ? value : `https://localhost:7053${value}`;
          return `- ${displayName}: ![${displayName}](${fullUrl})`;
        }

        return `- ${displayName}: ${value}`;
      })
      .filter(Boolean)
      .join('\n');

    // Th√™m x·ª≠ l√Ω tr∆∞·ªùng imageUrl n·∫øu kh√¥ng c√≥ trong displayMap
    if (data.imageUrl && typeof data.imageUrl === 'string') {
      const fullUrl = data.imageUrl.startsWith('http')
        ? data.imageUrl
        : `https://localhost:7053${data.imageUrl}`;
      dataMessage += `\n- H√¨nh ·∫£nh: ![H√¨nh ·∫£nh](${fullUrl})`;
    }

    // Th√™m ti√™u ƒë·ªÅ chi ti·∫øt n·∫øu c√≥ d·ªØ li·ªáu
    if (dataMessage) {
      dataMessage = `\n${dataMessage}`;
    }
  } else if (result.response.data) {
    // X·ª≠ l√Ω c√°c endpoint kh√¥ng c√≥ trong paramDisplayMap
    dataMessage = Object.entries(result.response.data)
      .map(([key, value]) => {
        if (value === null || value === undefined || key.toLowerCase().includes('id')) return null;
        if (key === 'createdAt') return `- Th·ªùi gian t·∫°o: ${value}`;
        if (key === 'fullName') return `- H·ªç t√™n: ${value}`;
        if (key === 'gender') {
          const genderOption = genderOptions.find((opt) => opt.value === value);
          return `- Gi·ªõi t√≠nh: ${genderOption ? genderOption.label : value}`;
        }
        if (key === 'phoneNumber') return `- S·ªë ƒëi·ªán tho·∫°i: ${value}`;
        if (key === 'phoneNumberRelative') return `- S·ªë ƒëi·ªán tho·∫°i ng∆∞·ªùi th√¢n: ${value}`;
        if (key === 'content') return `- N·ªôi dung: ${value}`;
        if (key === 'estimatedDuration') return `- Th·ªùi gian d·ª± ki·∫øn: ${value} ph√∫t`;
        if (key === 'status') return `- Tr·∫°ng th√°i: ${value === 1 ? 'ƒê√£ x√°c nh·∫≠n' : 'Ch∆∞a x√°c nh·∫≠n'}`;
        if (key === 'scope') {
          const scopeOption = scopeOptions.find(
            (opt) => opt.value === value || opt.value.toString() === value.toString()
          );
          return `- Ph·∫°m vi: ${scopeOption ? scopeOption.label : value}`;
        }
        if (key === 'imageUrl' || key === 'image' || key === 'profileImage' || key === 'backgroundImage') {
          const fullUrl = value.startsWith('http') ? value : `https://localhost:7053${value}`;
          return `- H√¨nh ·∫£nh: ![H√¨nh ·∫£nh](${fullUrl})`;
        }
        if (key === 'images' && Array.isArray(value)) {
          return value
            .map((img, index) => {
              const fullUrl = img.startsWith('http') ? img : `https://localhost:7053${img}`;
              return `- H√¨nh ·∫£nh ${index + 1}: ![H√¨nh ·∫£nh ${index + 1}](${fullUrl})`;
            })
            .join('\n');
        }
        return null;
      })
      .filter(Boolean)
      .join('\n');

    if (dataMessage) {
      dataMessage = `\n${dataMessage}`;
    }
  }

  // K·∫øt h·ª£p successMessage v√† dataMessage
  const combinedMessage = `${successMessage}${dataMessage}`;

  // G·ª≠i combinedMessage ƒë·∫øn server
  if (chatHistoryId) {
    await axiosClient.post(`/api/ChatAI/update-message`, {
      chatHistoryId,
      successMessage: combinedMessage,
      redisKey: redis_key,
    });
  } else {
    console.warn('[ChatInterface] Skipping update-message due to missing chatHistoryId');
  }

  // C·∫≠p nh·∫≠t messages v·ªõi combinedMessage
  setMessages((prev) => {
    const updatedMessages = prev.filter((msg) => msg.id !== `confirmation-${streamId}` && !msg.isConfirmationModal);
    return [
      ...updatedMessages,
      {
        id: `ai-confirm-${chatHistoryId || Date.now()}`,
        content: combinedMessage,
        isUser: false,
        isStreaming: false,
        showDots: false,
        timestamp: new Date().toISOString(),
        conversationId,
      },
    ].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
  });

  if (conversationId) {
    dispatch(fetchChatHistory({ conversationId, lastMessageId: null }));
  }
}else {
        // L·ªói: T·∫°o th√¥ng b√°o l·ªói th√¢n thi·ªán v√† g·ª≠i ƒë·∫øn server
        const serverErrorMessage = result.response?.message || 'ƒê√£ x·∫£y ra l·ªói kh√¥ng x√°c ƒë·ªãnh.';
        const friendlyMessage = friendlyErrorMessages[Math.floor(Math.random() * friendlyErrorMessages.length)];
        const combinedErrorMessage = `${friendlyMessage} L·ªói: ${serverErrorMessage}`;

        if (chatHistoryId) {
          await axiosClient.post(`/api/ChatAI/update-message`, {
            chatHistoryId,
            successMessage: combinedErrorMessage,
            redisKey: redis_key,
          });
        } else {
          console.warn('[ChatInterface] Skipping update-message due to missing chatHistoryId');
        }

        setMessages((prev) => {
          const updatedMessages = prev.filter((msg) => !msg.isConfirmationModal);
          return [
            ...updatedMessages,
            {
              id: `error-${Date.now()}`,
              content: combinedErrorMessage,
              isUser: false,
              isStreaming: false,
              showDots: false,
              isError: true,
              timestamp: new Date().toISOString(),
              conversationId,
            },
          ].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        });
      }

      setIsModalOpen(false);
      setIsWaitingResponse(false);
    } catch (error) {
      // X·ª≠ l√Ω l·ªói ngo·∫°i l·ªá (v√≠ d·ª•: l·ªói m·∫°ng)
      console.error('[ChatInterface] Error confirming action:', {
        message: error.message,
        response: error.response?.data,
        status: error.response?.status,
      });
      const serverErrorMessage = error.response?.data?.message || 'ƒê√£ x·∫£y ra l·ªói khi x√°c nh·∫≠n h√†nh ƒë·ªông.';
      const friendlyMessage = friendlyErrorMessages[Math.floor(Math.random() * friendlyErrorMessages.length)];
      const combinedErrorMessage = `${friendlyMessage} L·ªói: ${serverErrorMessage}`;

      const confirmationMessage = messages.find((msg) => msg.id === `confirmation-${streamId}`);
      const chatHistoryId = confirmationMessage?.chatHistoryId || null;

      if (chatHistoryId) {
        await axiosClient.post(`/api/ChatAI/update-message`, {
          chatHistoryId,
          successMessage: combinedErrorMessage,
          redisKey: redis_key,
        });
      } else {
        console.warn('[ChatInterface] Skipping update-message due to missing chatHistoryId');
      }

      setMessages((prev) => {
        const updatedMessages = prev.filter((msg) => !msg.isConfirmationModal);
        return [
          ...updatedMessages,
          {
            id: `error-${Date.now()}`,
            content: combinedErrorMessage,
            isUser: false,
            isStreaming: false,
            showDots: false,
            isError: true,
            timestamp: new Date().toISOString(),
            conversationId,
          },
        ].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
      });
      setIsModalOpen(false);
      setIsWaitingResponse(false);
    }
  },
  [dispatch, conversationId, messages]
);



  const handleModalEdit = useCallback((modalStreamId) => { // Ch·∫•p nh·∫≠n modalStreamId l√†m tham s·ªë
    console.log('[ChatInterface] Entering edit mode for modal with streamId:', modalStreamId);
    setMessages((prevMessages) =>
      prevMessages.map((msg) =>
        msg.id === `confirmation-${modalStreamId}` // S·ª≠ d·ª•ng modalStreamId ƒë∆∞·ª£c truy·ªÅn v√†o
          ? { ...msg, isEditing: true }
          : msg
      )
    );
  }, []);



  const handleModalCancel = useCallback((streamId) => {
    console.log('[ChatInterface] Cancelling modal action', { streamId });
  
    const confirmationMessage = messages.find(
      (msg) => msg.id === `confirmation-${streamId}` && msg.isConfirmationModal
    );
    console.log('[handleModalCancel] Confirmation message:', confirmationMessage);
    console.log('[handleModalCancel] Results:', confirmationMessage?.results);
  
    const redis_key = confirmationMessage?.results?.[0]?.redis_key;
    const validConversationId = conversationId || confirmationMessage?.conversationId;
  
    if (validConversationId && redis_key) {
      dispatch(stopAction({ conversationId: validConversationId, redis_key }))
        .unwrap()
        .then(() => {
          console.log('[ChatInterface] Stop action successful');
          setMessages((prev) => {
            const updatedMessages = prev.filter((msg) => !msg.isConfirmationModal);
            console.log('[ChatInterface] Messages after cancelling modal:', updatedMessages);
            return [
              ...updatedMessages,
              {
                id: `cancel-${Date.now()}`,
                content: 'H√†nh ƒë·ªông ƒë√£ ƒë∆∞·ª£c h·ªßy.',
                isUser: false,
                isStreaming: false,
                showDots: false,
                timestamp: new Date().toISOString(),
              },
            ];
          });
          setIsWaitingResponse(false);
        })
        .catch((error) => {
          console.error('[ChatInterface] Error stopping action:', error);
          setMessages((prev) => {
            const updatedMessages = prev.filter((msg) => !msg.isConfirmationModal);
            console.log('[ChatInterface] Messages after cancelling modal:', updatedMessages);
            return [
              ...updatedMessages,
              {
                id: `error-${Date.now()}`,
                content: 'L·ªói khi h·ªßy h√†nh ƒë·ªông. Vui l√≤ng th·ª≠ l·∫°i.',
                isUser: false,
                isStreaming: false,
                showDots: false,
                isError: true,
                timestamp: new Date().toISOString(),
              },
            ];
          });
          setIsWaitingResponse(false);
        });
    } else {
      console.warn('[ChatInterface] Kh√¥ng t√¨m th·∫•y redis_key ho·∫∑c conversationId:', {
        redis_key,
        conversationId: validConversationId,
        results: confirmationMessage?.results?.[0],
      });
      setMessages((prev) => {
        const updatedMessages = prev.filter((msg) => !msg.isConfirmationModal);
        console.log('[ChatInterface] Messages after cancelling modal:', updatedMessages);
        return [
          ...updatedMessages,
          {
            id: `cancel-${Date.now()}`,
            content: 'H√†nh ƒë·ªông ƒë√£ ƒë∆∞·ª£c h·ªßy.',
            isUser: false,
            isStreaming: false,
            showDots: false,
            timestamp: new Date().toISOString(),
          },
        ];
      });
      setIsWaitingResponse(false);
    }
  }, [dispatch, conversationId, messages]);
const extractImageUrl = (content) => {
  // T√¨m ki·∫øm ƒë∆∞·ªùng d·∫´n h√¨nh ·∫£nh trong n·ªôi dung
  const imagePathMatch = content.match(/Link ·∫£nh: ?[`"]?(\/images\/posts\/[^\s`")\]\n]+)[`"]?/i);
  if (imagePathMatch) {
    return `https://localhost:7053${imagePathMatch[1]}`;
  }
  return null;
};

const processContent = (content) => {
  if (!content) return content;

  const imageUrl = extractImageUrl(content);
  console.log('[processContent] Extracted image URL:', imageUrl);

  // Thay th·∫ø ƒëo·∫°n "C√≥ h√¨nh ·∫£nh ƒë√≠nh k√®m. (Link ·∫£nh: ...)" b·∫±ng c√∫ ph√°p markdown cho h√¨nh ·∫£nh trong danh s√°ch
  let processedContent = content
    .replace(/\(b·∫°n c√≥ th·ªÉ xem h√¨nh ·∫£nh t·∫°i ƒë√¢y:.*?\)/g, '')
    .replace(/\[ƒê√¢y l√† link ƒë·∫øn h√¨nh ·∫£nh b√†i vi·∫øt.*?\]/g, '')
    .replace(
      /C√≥ h√¨nh ·∫£nh ƒë√≠nh k√®m\.\s*\(Link ·∫£nh:.*?`?\)/g,
      imageUrl ? `\n* ![B√†i ƒëƒÉng](${imageUrl})` : ''
    )
    .trim();

  // X√≥a c√°c d√≤ng "H√¨nh ·∫£nh: ..." c√≤n l·∫°i tr∆∞·ªõc khi th√™m c√∫ ph√°p markdown
  processedContent = processedContent.replace(/(\*|_)\s*\*\*H√¨nh ·∫£nh:\*\*\s*(?!\!)/g, '');

  console.log('[processContent] Processed content:', processedContent);
  return processedContent;
};

const renderMessage = useCallback(
  (message, index) => {
    console.log('[ChatInterface] Rendering message:', message);

    if (message.isConfirmationModal) {
      const modifiedMessage = {
        ...message,
        isStreaming: false,
        showDots: false,
      };

      return (
        <div
          key={`${modifiedMessage.id}-${index}`}
          className="message-bubble ai-message confirmation-message"
          data-testid={`message-${modifiedMessage.id}`}
        >
          <ConfirmationModal
            results={modifiedMessage.results}
            streamId={modifiedMessage.streamId} 
            onConfirm={(endpoint, params, redis_key) => handleModalConfirm(endpoint, params, redis_key, modifiedMessage.streamId)}
            onEdit={handleModalEdit}
            onCancel={() => handleModalCancel(modifiedMessage.streamId)}
            conversationId={conversationId}
            isEditing={modifiedMessage.isEditing || false}
          />
          <div className="message-timestamp">
            {new Date(modifiedMessage.timestamp).toLocaleTimeString([], {
              hour: '2-digit',
              minute: '2-digit',
            })}
          </div>
        </div>
      );
    }

    return (
      <div
        key={`${message.id}-${index}`}
        className={`message-bubble ${message.isUser ? 'user-message' : `ai-message ${message.isStreaming ? 'streaming' : ''}`}`}
        data-testid={`message-${message.id}`}
      >
        <div className="message-content">
          {message.content ? (
            <>
              <ReactMarkdown
                remarkPlugins={[remarkGfm]}
                rehypePlugins={[rehypeHighlight]}
                components={{
                  img: ({ src, alt }) => (
                    <img
                      src={src}
                      alt={alt}
                      className="post-media-image"
                      onError={(e) => {
                        console.error('[renderMessage] Image failed to load:', src);
                        e.target.onerror = null;
                        e.target.src = '/placeholder-image.png';
                      }}
                      style={{ maxWidth: '100%', maxHeight: '300px', margin: '8px 0' }}
                    />
                  ),
                }}
              >
                {convertLinksToMarkdown(processContent(message.content))}
              </ReactMarkdown>
            </>
          ) : (
            <span>{message.isStreaming ? '' : 'Kh√¥ng c√≥ n·ªôi dung tr·∫£ l·ªùi.'}</span>
          )}
          {message.isStreaming && message.showDots && (
            <span className="streaming-dots" data-testid="streaming-dots">
              <span>.</span>
              <span>.</span>
              <span>.</span>
            </span>
          )}
        </div>
        <div className="message-timestamp">
          {new Date(message.timestamp).toLocaleTimeString([], {
            hour: '2-digit',
            minute: '2-digit',
          })}
        </div>
      </div>
    );
  },
  [handleModalConfirm, handleModalEdit, handleModalCancel, conversationId]
);
  

  const renderedMessages = useMemo(() => {
    return messages.map((message, index) => renderMessage(message, index));
  }, [messages, renderMessage]);

  return (
    <div className="chat-interface">
      <div className="chat-header">
        <button onClick={toggleSidebar} className="menu-button">
          <Menu size={20} />
        </button>
        <h2 className="chat-title">
          {conversationId ? currentConversation?.title || 'Cu·ªôc tr√≤ chuy·ªán' : 'Chat AI'}
        </h2>
        <button onClick={handleNewChat} className="new-chat-button">
          <Plus size={20} />
        </button>
      </div>

      <div className="chat-messages">
        {messages.length > 0 ? (
          <>{renderedMessages}</>
        ) : (
          <div className="welcome-screen">
            <div className="welcome-content">
              <h3>Ch√†o m·ª´ng ƒë·∫øn v·ªõi Chat AI</h3>
              <p>H√£y b·∫Øt ƒë·∫ßu cu·ªôc tr√≤ chuy·ªán m·ªõi ho·∫∑c ch·ªçn t·ª´ l·ªãch s·ª≠</p>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <div className="chat-input-container">
        <div className="chat-input">
          <textarea
            ref={inputRef}
            value={query}
            onChange={(e) => setQuery(e.target.value)}
            onKeyDown={handleKeyDown}
            placeholder="Nh·∫≠p tin nh·∫Øn..."
            rows={1}
            disabled={isWaitingResponse || isModalOpen || isListening} // Disable khi ƒëang nghe
          />
          {/* N√∫t Microphone */}
        {(window.SpeechRecognition || window.webkitSpeechRecognition) && (
          <button
            onClick={handleToggleListening}
            className={`mic-button ${isListening ? 'listening' : ''}`} // Th√™m class 'listening' ƒë·ªÉ c√≥ th·ªÉ style kh√°c bi·ªát
            title={isListening ? "D·ª´ng ghi √¢m" : "Ghi √¢m gi·ªçng n√≥i"}
            disabled={isWaitingResponse || isModalOpen} // isModalOpen v√† isWaitingResponse l√† v√≠ d·ª•
          >
            {isListening ? <StopCircle size={18} color="red" /> : <Mic size={18} />}
          </button>
        )}
          <button
            onClick={handleSendQuery}
            disabled={!query.trim() || isWaitingResponse || isListening} // Disable khi ƒëang nghe
            className="send-button"
          >
            {isWaitingResponse ? <div className="spinner" /> : <Send size={18} />}
          </button>
        </div>
      </div>

      {error && <div className="error-message">{error}</div>}
    
    </div>
  );
};

export default ChatInterface;